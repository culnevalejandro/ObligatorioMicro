.globl convertirAAscii
.globl imprimir_texto
.globl convert_int_to_ascii
	
	.data
	exclamacion: .byte	0x00,0x00,0x06,0x5F,0x5F,0x06,0x00,0x00
	comillas: .byte	0x00,0x03,0x03,0x00,0x03,0x03,0x00,0x00
numeral: .byte	0x14,0x7F,0x7F,0x14,0x7F,0x7F,0x14,0x00
pesos:.byte	0x24,0x2E,0x6B,0x6B,0x3A,0x12,0x00,0x00
porcentaje: .byte	0x46,0x66,0x30,0x18,0x0C,0x66,0x62,0x00
ampersan: .byte	0x30,0x7A,0x4F,0x5D,0x37,0x7A,0x48,0x00
comillasimple: .byte	0x04,0x07,0x03,0x00,0x00,0x00,0x00,0x00
parentesisizquierdo:.byte	0x00,0x1C,0x3E,0x63,0x41,0x00,0x00,0x00
parentesisderecho: .byte 0x00,0x41,0x63,0x3E,0x1C,0x00,0x00,0x00
asterisco: .byte 0x08,0x2A,0x3E,0x1C,0x1C,0x3E,0x2A,0x08
suma: .byte 0x08,0x08,0x3E,0x3E,0x08,0x08,0x00,0x00
coma: .byte 0x00,0x80,0xE0,0x60,0x00,0x00,0x00,0x00
resta: .byte 0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00
punto: .byte 0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00
barra: .byte 0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00
	0: .byte 0x3E,0x7F,0x71,0x59,0x4D,0x7F,0x3E,0x00
	1: .byte 0x40,0x42,0x7F,0x7F,0x40,0x40,0x00,0x00
	2: .byte 0x62,0x73,0x59,0x49,0x6F,0x66,0x00,0x00
	3: .byte 0x22,0x63,0x49,0x49,0x7F,0x36,0x00,0x00
	4: .byte 0x18,0x1C,0x16,0x53,0x7F,0x7F,0x50,0x00
	5: .byte 0x27,0x67,0x45,0x45,0x7D,0x39,0x00,0x00
	6: .byte 0x3C,0x7E,0x4B,0x49,0x79,0x30,0x00,0x00
	7: .byte 0x03,0x03,0x71,0x79,0x0F,0x07,0x00,0x00
	8: .byte 0x36,0x7F,0x49,0x49,0x7F,0x36,0x00,0x00
	9: .byte 0x06,0x4F,0x49,0x69,0x3F,0x1E,0x00,0x00
	dos_puntos: .byte 0x00,0x00,0x66,0x66,0x00,0x00,0x00,0x00
	punto_coma: .byte 0x00,0x80,0xE6,0x66,0x00,0x00,0x00,0x00
	menor_que: .byte 0x08,0x1C,0x36,0x63,0x41,0x00,0x00,0x00
	igual: .byte 0x24,0x24,0x24,0x24,0x24,0x24,0x00,0x00
	mayor_que: .byte 0x00,0x41,0x63,0x36,0x1C,0x08,0x00,0x00
	interrogacion: .byte 0x02,0x03,0x51,0x59,0x0F,0x06,0x00,0x00
	arroba: .byte 0x3E,0x7F,0x41,0x5D,0x5D,0x1F,0x1E,0x00
	a: .byte 0x7C,0x7E,0x13,0x13,0x7E,0x7C,0x00,0x00
	b: .byte 0x41, 0x7F, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00
	c: .byte 0x1C, 0x3E, 0x63, 0x41, 0x41, 0x63, 0x22, 0x00
	d: .byte 0x41, 0x7F, 0x7F, 0x41, 0x63, 0x3E, 0x1C, 0x00
	e: .byte 0x41, 0x7F, 0x7F, 0x49, 0x5D, 0x41, 0x63, 0x00
	f: .byte 0x41, 0x7F, 0x7F, 0x49, 0x1D, 0x01, 0x03, 0x00
	g: .byte 0x1C, 0x3E, 0x63, 0x41, 0x51, 0x73, 0x72, 0x00
	h: .byte 0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F, 0x00, 0x00
	i: .byte 0x00, 0x41, 0x7F, 0x7F, 0x41, 0x00, 0x00, 0x00
	j: .byte 0x30, 0x70, 0x40, 0x41, 0x7F, 0x3F, 0x01, 0x00
	k: .byte 0x41, 0x7F, 0x7F, 0x08, 0x1C, 0x77, 0x63, 0x00
	l: .byte 0x41, 0x7F, 0x7F, 0x41, 0x40, 0x60, 0x70, 0x00
	m: .byte 0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F, 0x00
	n: .byte 0x7F, 0x7F, 0x06, 0x0C, 0x18, 0x7F, 0x7F, 0x00
	o: .byte 0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C, 0x00
	p: .byte 0x41, 0x7F, 0x7F, 0x49, 0x09, 0x0F, 0x06, 0x00
	q: .byte 0x1E, 0x3F, 0x21, 0x71, 0x7F, 0x5E, 0x00, 0x00
	r: .byte 0x41, 0x7F, 0x7F, 0x09, 0x19, 0x7F, 0x66, 0x00
	s: .byte 0x26, 0x6F, 0x4D, 0x59, 0x73, 0x32, 0x00, 0x00
	t: .byte 0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03, 0x00, 0x00
	u: .byte 0x7F, 0x7F, 0x40, 0x40, 0x7F, 0x7F, 0x00, 0x00
	v: .byte 0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F, 0x00, 0x00
	w: .byte 0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F, 0x00
	x: .byte 0x43, 0x67, 0x3C, 0x18, 0x3C, 0x67, 0x43, 0x00
	y: .byte 0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07, 0x00, 0x00
	z: .byte 0x47, 0x63, 0x71, 0x59, 0x4D, 0x67, 0x73, 0x00
	
	
	buffer: .space 1024  # Espacio de memoria para almacenar el texto convertido a ascii
	ascii_digits: .asciiz "0123456789"
	
	
.text
	
	
	# Recibe en a0 la page y columna inicial, igual que draw bitmap
	# Recibe en a2 la direccion de memoria que contiene cadena de ascii a imprimir
imprimir_texto:
	
	addi		$sp, $sp, -12
	sw			$ra, ($sp)
	sw			$s1, 4($sp)
	sw			$s2, 8($sp)
	
	move		$s1, $a2
	move		$s2, $a0
	
	loop:
	andi		$t0, $s2, 0x80 
	bne			$t0, 0x80, imprimir 
	addi		$s2, $s2, 0x0100 # Salto de page
	andi		$s2, $s2, 0xFF00 # Reset columna
imprimir:
	la			$t1, a
	lb			$t0, ($s1) # Cargo la letra 
	beq			$t0, $0, fin_texto
	beq			$t0, 32, espacio
	addi		$t0, $t0, -65
	mul			$t0, $t0, 8
	add			$t1, $t0, $t1
	move		$a0, $s2
	li			$a1, 0x0808
    add			$a2, $0, $t1
    jal			draw_bitmap
	
espacio:
	
	addi		$s1, $s1, 1
	addi		$s2, $s2, 8
	j			loop
	
	
fin_texto:
	lw			$ra, ($sp)
	lw			$s1, 4($sp)
    lw			$s2, 8($sp)
 	addi		$sp, $sp, 12
	
	
	jr			$ra
	
	

#	PARAM
#	$a0 int mem dir
#	$a1 qty to convert
#	OUTPUT -> converted mem dir
convert_int_to_ascii:
    addi		$sp, $sp, -16
    sw			$ra, 0($sp)
    sw			$s1, 4($sp)
    sw			$s2, 8($sp)
    sw			$s3, 12($sp)

    move		$s1, $a0
    move		$s4, $a1
    la			$s2, buffer					# mem dir ascii to store
    la			$s3, ascii_digits			# mem dir ascii digits

convert_loop:
    beq			$s4, $zero, end_convert		# end if no more to convert

    lw			$t0, 0($s1)
	
	bgez		$t0, exit_negativo
	li			$t2,45
	sb			$t2, 0($s2)					# store ascii in buffer
    addi		$s2, $s2, 1
	mul			$t0, $t0, -1
	
	exit_negativo:

    # init div
    li			$t1, 1						# initial div
    move		$t4, $t0					# store original int

	# increase div until it reaches the most significant digit 
prep_div:
    li			$t5, 10
    div			$t4, $t5
    mflo		$t6
    beq			$t6, $zero, convert_digit	# if zero, div correct
    mul			$t1, $t1, 10				# else keep increasing div
    j			prep_div

convert_digit:
    div			$t0, $t1
    mflo		$t2
    addi		$t2, $t2, 48				# conv digit to ascii
    sb			$t2, 0($s2)					# store ascii in buffer
    addi		$s2, $s2, 1

    mfhi		$t0							# store rem for next iteration
    div			$t1, $t1, 10				# div divisor
    bnez		$t1, convert_digit			# repeat if more digits to convert

    # add space between numbers
    li			$t3, 32
    sb			$t3, 0($s2)
    addi		$s2, $s2, 1

    addi		$s1, $s1, 4
    addi		$s4, $s4, -1
    j			convert_loop

end_convert:
    sb			$zero, 0($s2)				# add null to ascii

    lw			$ra, 0($sp)
    lw			$s1, 4($sp)
    lw			$s2, 8($sp)
    lw			$s3, 12($sp)
    addi		$sp, $sp, 16

    la			$v0, buffer

	
	jr			$ra
	

